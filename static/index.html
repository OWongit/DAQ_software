<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAQ Monitor</title>
    <link rel="icon" href="/images/favicon.png" type="image/png">
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Smoothie.js for real-time graphs -->
    <script src="https://cdn.jsdelivr.net/npm/smoothie@1.36.0/smoothie.min.js"></script>
    <!-- Socket.IO client -->
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100vh;
            background-color: #000000;
        }
        .graph-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-sizing: border-box;
            padding-bottom: 25px; /* Space for bottom labels */
        }
        .graph-container canvas {
            display: block;
            width: 100%;
            flex: 1;
            min-height: 0;
            box-sizing: border-box;
        }
        .connection-status {
            position: fixed;
            top: 17px;
            left: 10px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .connection-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .connection-indicator.connected {
            background-color: #22c55e;
            box-shadow: 0 0 12px rgba(34, 197, 94, 0.8), 0 0 24px rgba(34, 197, 94, 0.4);
        }
        .connection-indicator.disconnected {
            background-color: #ef4444;
        }
        .connection-text {
            color: white;
            font-size: 11px;
            font-weight: 500;
        }
        .download-button {
            padding: 8px 8px;
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: background-color 0.2s;
        }
        .download-button:hover {
            background-color: #2563eb;
        }
        .download-button:disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
        }
        .system-info {
            position: fixed;
            top: 11px;
            left: 70px;
            z-index: 1000;
            background-color: rgba(56, 56, 56, 0.9);
            border-radius: 6px;
            padding: 6px 10px;
            cursor: pointer;
            transition: background-color 0.2s;
            max-width: calc(100vw - 250px);
        }
        .system-info:hover {
            background-color: rgb(36, 36, 36);
        }
        .system-info-compact {
            color: white;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }
        .system-info-compact span {
            color: rgba(255, 255, 255, 0.8);
        }
        .system-info-expanded {
            display: none;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 10px;
        }
        .system-info.expanded .system-info-expanded {
            display: block;
        }
        .system-info-expanded div {
            margin: 4px 0;
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }
        .system-info-expanded .label {
            color: rgba(255, 255, 255, 0.6);
        }
        .system-info-expanded .value {
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
        }
        .top-right-actions {
            position: fixed;
            top: 7px;
            right: 10px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .settings-button {
            padding: 8px;
            background-color: rgba(56, 56, 56, 0.9);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }
        .settings-button:hover {
            background-color: rgb(36, 36, 36);
        }
        .settings-button svg {
            width: 20px;
            height: 20px;
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        .modal-overlay.open {
            display: flex;
        }
        .modal-box {
            background-color: #0a0a0a;
            border-radius: 10px;
            padding: 24px;
            max-width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.8), 0 0 0 1px rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .modal-box h2 {
            color: #fff;
            font-size: 20px;
            font-weight: 600;
            margin: 0 0 16px 0;
            letter-spacing: 0.02em;
        }
        .modal-intro {
            color: #b4b8bc;
            font-size: 12px;
            margin: 0 0 16px 0;
        }
        .modal-section {
            margin-bottom: 24px;
        }
        .modal-section h3 {
            color: #e5e7eb;
            font-size: 14px;
            font-weight: 600;
            margin: 0 0 12px 0;
            letter-spacing: 0.03em;
        }
        .settings-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }
        .settings-row label {
            color: #d1d5db;
            font-size: 12px;
            font-weight: 500;
            min-width: 80px;
        }
        .settings-row input[type="number"] {
            width: 90px;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: #171717;
            color: #fff;
        }
        .settings-row input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            transition: box-shadow 0.2s;
        }
        .settings-row input[type="checkbox"]:checked {
            box-shadow: 0 0 14px rgba(34, 197, 94, 0.7), 0 0 24px rgba(34, 197, 94, 0.35);
        }

        .settings-row input[type="text"].display-name {
            flex: 1;
            min-width: 120px;
            max-width: 200px;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: #171717;
            color: #fff;
            font-size: 12px;
        }
        .settings-row select.unit-select {
            min-width: 90px;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: #171717;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
        }
        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: flex-end;
        }
        .modal-actions button {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            border: none;
        }
        .modal-actions .btn-save {
            background-color: #2563eb;
            color: white;
            font-weight: 600;
        }
        .modal-actions .btn-save:hover {
            background-color: #3b82f6;
            box-shadow: 0 0 16px rgba(59, 130, 246, 0.4);
        }
        .modal-actions .btn-cancel {
            background-color: #374151;
            color: #e5e7eb;
        }
        .modal-actions .btn-cancel:hover {
            background-color: #4b5563;
        }
        .settings-saved-msg {
            color: #22c55e;
            font-size: 12px;
            margin-left: 10px;
            display: none;
        }
        .settings-saved-msg.show {
            display: inline;
        }
        .settings-note {
            color: #9ca3af;
            font-size: 11px;
            margin-top: 8px;
            display: block;
        }
        .adc-slider-row {
            display: flex;
            align-items: center;
            gap: 14px;
            margin-bottom: 10px;
        }
        .adc-slider-row label {
            color: #f3f4f6;
            font-size: 13px;
            font-weight: 600;
            min-width: auto;
        }
        .adc-slider-row input[type="range"] {
            width: 120px;
            accent-color: #3b82f6;
        }
        #adc_datarate_value {
            color: #60a5fa;
            font-weight: 600;
            font-size: 14px;
            min-width: 24px;
        }
        .settings-explanation {
            color: #9ca3af;
            font-size: 11px;
            margin: 4px 0 12px 0;
            max-width: 480px;
        }
        .settle-discard-toggle {
            padding: 8px 18px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        .settle-discard-toggle.enabled {
            background-color: #22c55e;
            color: white;
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.6), 0 0 40px rgba(34, 197, 94, 0.3);
        }
        .settle-discard-toggle.enabled:hover {
            box-shadow: 0 0 24px rgba(34, 197, 94, 0.7), 0 0 48px rgba(34, 197, 94, 0.35);
        }
        .settle-discard-toggle.disabled {
            background-color: #4b5563;
            color: #d1d5db;
        }
        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background-color: rgba(20, 20, 20, 0.95);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 999;
        }
        .bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background-color: rgba(20, 20, 20, 0.95);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 5px;
            z-index: 999;
        }
        .bottom-bar-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .bottom-bar-left img {
            height: 28px;
            width: auto;
            display: block;
        }
        .bottom-bar-left .daq-label {
            color: #e5e7eb;
            font-size: 16px;
            font-weight: 600;
            letter-spacing: 0.05em;
        }
        .bottom-bar-center {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
        }
        .bottom-bar-right {
            color: rgba(255, 255, 255, 0.85);
            font-size: 13px;
            font-weight: 500;
            font-variant-numeric: tabular-nums;
        }
    </style>
</head>
<body>
    <!-- Top bar (same background as bottom bar) -->
    <div class="top-bar"></div>
    <!-- Connection Status Indicator -->
    <div class="connection-status">
        <div id="connection-indicator" class="connection-indicator disconnected"></div>
        <span id="connection-text" class="connection-text">offline</span>
    </div>
    
    <!-- System Info Display -->
    <div id="system-info" class="system-info" style="display: none;">
        <div class="system-info-compact" id="system-info-compact">
            <span>CPU: <span id="sys-cpu-temp">--</span>°C</span>
            <span>|</span>
            <span>RAM: <span id="sys-ram-used">--</span>/<span id="sys-ram-total">--</span></span>
            <span>|</span>
            <span>CPU: <span id="sys-cpu-use">--</span>%</span>
            <span>|</span>
            <span>Disk: <span id="sys-disk-percent">--</span></span>
        </div>
        <div class="system-info-expanded">
            <div>
                <span class="label">CPU Temperature:</span>
                <span class="value" id="sys-detail-cpu-temp">--</span>
            </div>
            <div>
                <span class="label">RAM Total:</span>
                <span class="value" id="sys-detail-ram-total">--</span>
            </div>
            <div>
                <span class="label">RAM Used:</span>
                <span class="value" id="sys-detail-ram-used">--</span>
            </div>
            <div>
                <span class="label">RAM Free:</span>
                <span class="value" id="sys-detail-ram-free">--</span>
            </div>
            <div>
                <span class="label">CPU Usage:</span>
                <span class="value" id="sys-detail-cpu-use">--</span>
            </div>
            <div>
                <span class="label">Disk Total:</span>
                <span class="value" id="sys-detail-disk-total">--</span>
            </div>
            <div>
                <span class="label">Disk Used:</span>
                <span class="value" id="sys-detail-disk-used">--</span>
            </div>
            <div>
                <span class="label">Disk Free:</span>
                <span class="value" id="sys-detail-disk-free">--</span>
            </div>
            <div>
                <span class="label">Disk Usage:</span>
                <span class="value" id="sys-detail-disk-percent">--</span>
            </div>
        </div>
    </div>
    
    <!-- Top right: Settings gear + Download -->
    <div class="top-right-actions">
        <button id="settings-button" class="settings-button" title="Settings" aria-label="Settings">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"/>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
            </svg>
        </button>
        <button id="download-button" class="download-button" disabled>
            Download CSV
        </button>
    </div>

    <!-- Settings modal -->
    <div id="settings-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal-box">
            <h2>Settings</h2>
            <p class="modal-intro">Changes take effect after app restart. Values are saved across sessions.</p>
            <div id="settings-form-container"></div>
            <span id="settings-csv-note" class="settings-note">ANOTHER SENSOR DATA CSV FILE WILL BE CREATED UPON RESTART</span>
            <div class="modal-actions">
                <span id="settings-saved-msg" class="settings-saved-msg">Saved. Restarting...</span>
                <button id="settings-cancel" class="btn-cancel">Cancel</button>
                <button id="settings-save" class="btn-save">Save and RESTART</button>
            </div>
        </div>
    </div>
    
    <!-- Graph Grid Container -->
    <div id="graphs-container" class="w-full h-screen grid gap-2 p-2" style="grid-auto-rows: 1fr; overflow: hidden; box-sizing: border-box; padding-top: 50px; padding-bottom: 40px;"></div>

    <!-- Bottom bar -->
    <div class="bottom-bar">
        <div class="bottom-bar-left">
            <img src="/images/SARP_LOGO_MK2.png" alt="">
            <span class="daq-label">Data Acquisition System</span>
        </div>
        <div class="bottom-bar-center">© Society for Advanced Rocket Propulsion (SARP)</div>
        <div class="bottom-bar-right"><span id="bottom-bar-time"></span></div>
    </div>

    <script>
        // Bottom bar time (far right)
        function updateBottomBarTime() {
            const el = document.getElementById('bottom-bar-time');
            if (el) el.textContent = new Date().toLocaleTimeString();
        }
        updateBottomBarTime();
        setInterval(updateBottomBarTime, 1000);

        // SocketIO connection
        const socket = io();
        
        // Color list for sensor graphs
        const COLOR_LIST = [
            '#bbbbbb', 
            "#ff0000", 
            "#ff6200", 
            "#ffcc00", 
            "#80ff00",
            "#00ff7b", 
            "#00f2ff", 
            "#0077ff", 
            "#9000ff", 
            "#e600ff", 
            "#ff006a"
        ];
        
        // State
        let sensorCharts = {};
        let sensorTimeSeries = {};
        let sensorMinMax = {};
        let sensorCurrentValues = {}; // Store current values for display
        let sensorColors = {}; // Store line color for each sensor
        let currentFileName = null;
        let sensorLabels = [];
        let sensorDisplayNames = {}; // Display names from settings (e.g. LC1 -> "Strain Gauge 1")
        let sensorUnits = {}; // Selected unit per sensor (e.g. LC1 -> "lbf"); falls back to getSensorFormat().unit
        
        // Unit options typically found on sensor data sheets
        const LOAD_CELL_UNITS = [
            { value: 'lbf', label: 'lbf' }, { value: 'lb', label: 'lb' }, { value: 'lbs', label: 'lbs' },
            { value: 'N', label: 'N' }, { value: 'kN', label: 'kN' }, { value: 'kgf', label: 'kgf' },
            { value: 'oz', label: 'oz' }, { value: 'ton', label: 'ton (US)' }, { value: 'tonne', label: 'tonne' },
            { value: 'g', label: 'g' }
        ];
        const PRESSURE_UNITS = [
            { value: 'Pa', label: 'Pa' }, { value: 'kPa', label: 'kPa' }, { value: 'MPa', label: 'MPa' },
            { value: 'psi', label: 'psi' }, { value: 'psig', label: 'psig' }, { value: 'psia', label: 'psia' },
            { value: 'bar', label: 'bar' }, { value: 'mbar', label: 'mbar' },
            { value: 'inH2O', label: 'inH₂O' }, { value: 'ftH2O', label: 'ftH₂O' },
            { value: 'inHg', label: 'inHg' }, { value: 'mmHg', label: 'mmHg' },
            { value: 'atm', label: 'atm' }, { value: 'torr', label: 'torr' }, { value: 'psf', label: 'psf' }
        ];
        const RTD_UNITS = [
            { value: '°C', label: '°C' }, { value: '°F', label: '°F' }, { value: 'K', label: 'K' }, { value: '°R', label: '°R' }
        ];
        
        // Helper: unit and decimal places for sensor type (defaults; overridden by sensorUnits when user selects)
        function getSensorFormat(label) {
            if (label.startsWith('LC')) return { unit: 'lbf', decimals: 2 };
            if (label.startsWith('PT')) return { unit: 'Pa', decimals: 2 };
            if (label.startsWith('RTD')) return { unit: '°C', decimals: 1 };
            return { unit: '', decimals: 1 };
        }
        function getDisplayUnit(label) {
            return sensorUnits[label] != null && sensorUnits[label] !== '' ? sensorUnits[label] : getSensorFormat(label).unit;
        }
        
        // DOM elements
        const connectionIndicator = document.getElementById('connection-indicator');
        const connectionText = document.getElementById('connection-text');
        const downloadButton = document.getElementById('download-button');
        const graphsContainer = document.getElementById('graphs-container');
        const settingsModal = document.getElementById('settings-modal');
        const settingsFormContainer = document.getElementById('settings-form-container');
        const settingsSaveBtn = document.getElementById('settings-save');
        const settingsCancelBtn = document.getElementById('settings-cancel');
        const settingsSavedMsg = document.getElementById('settings-saved-msg');

        // Build settings form from API data and inject into container
        function buildSettingsForm(data) {
            if (!data || !data.load_cells || !data.pressure_transducers || !data.rtds) return;
            const adc = data.adc || { datarate_code: 10, settle_discard: true };
            const dr = Math.min(13, Math.max(0, parseInt(adc.datarate_code, 10) || 10));
            const sd = !!adc.settle_discard;
            let html = '';
            html += '<div class="modal-section"><h3>ADC</h3>';
            html += '<div class="adc-slider-row"><label>Data rate (0–13)</label><input type="range" id="adc_datarate_code" min="0" max="13" value="' + dr + '"><span id="adc_datarate_value">' + dr + '</span></div>';
            html += '<p class="settings-explanation">ADS124S08 data rate / filter. Higher = faster, noisier; lower = slower, quieter. 0=slow, 13=fastest.</p>';
            html += '<div class="adc-slider-row"><label>Settle discard</label>';
            html += '<input type="checkbox" id="adc_settle_discard" ' + (sd ? 'checked' : '') + ' style="display:none">';
            html += '<button type="button" id="adc_settle_discard_btn" class="settle-discard-toggle ' + (sd ? 'enabled' : 'disabled') + '">Enabled</button></div>';
            html += '<p class="settings-explanation">When enabled, discard one conversion per channel read for more stable readings (slower). When disabled, use one conversion per read (faster, may have small step response).</p>';
            html += '</div>';
            html += '<div class="modal-section"><h3>Load cells</h3>';
            for (const [name, cfg] of Object.entries(data.load_cells)) {
                const displayName = (cfg.display_name != null && cfg.display_name !== undefined) ? String(cfg.display_name) : '';
                const unit = (cfg.unit != null && cfg.unit !== undefined) ? String(cfg.unit) : 'lbf';
                const lcUnitOpts = LOAD_CELL_UNITS.map(u => `<option value="${u.value}" ${u.value === unit ? 'selected' : ''}>${u.label}</option>`).join('');
                html += `<div class="settings-row">
                    <label>${name}</label>
                    <label>Name <input type="text" class="display-name" id="lc_${name}_display_name" placeholder="e.g. Strain Gauge 1" value="${displayName.replace(/"/g, '&quot;')}"></label>
                    <label>Unit <select class="unit-select" id="lc_${name}_unit">${lcUnitOpts}</select></label>
                    <label><input type="checkbox" id="lc_${name}_enabled" ${cfg.enabled ? 'checked' : ''}> Enabled</label>
                    <label>Sensitivity <input type="number" id="lc_${name}_sensitivity" step="0.001" value="${Number(cfg.sensitivity)}"></label>
                    <label>Max load <input type="number" id="lc_${name}_max_load" step="0.01" value="${Number(cfg.max_load)}"></label>
                    <label>Offset <input type="number" id="lc_${name}_offset" step="0.01" value="${Number(cfg.offset ?? 0)}"></label>
                </div>`;
            }
            html += '</div><div class="modal-section"><h3>Pressure transducers</h3>';
            for (const [name, cfg] of Object.entries(data.pressure_transducers)) {
                const displayName = (cfg.display_name != null && cfg.display_name !== undefined) ? String(cfg.display_name) : '';
                const unit = (cfg.unit != null && cfg.unit !== undefined) ? String(cfg.unit) : 'Pa';
                const ptUnitOpts = PRESSURE_UNITS.map(u => `<option value="${u.value}" ${u.value === unit ? 'selected' : ''}>${u.label}</option>`).join('');
                html += `<div class="settings-row">
                    <label>${name}</label>
                    <label>Name <input type="text" class="display-name" id="pt_${name}_display_name" placeholder="e.g. Tank 1 Pressure" value="${displayName.replace(/"/g, '&quot;')}"></label>
                    <label>Unit <select class="unit-select" id="pt_${name}_unit">${ptUnitOpts}</select></label>
                    <label><input type="checkbox" id="pt_${name}_enabled" ${cfg.enabled ? 'checked' : ''}> Enabled</label>
                    <label>P min <input type="number" id="pt_${name}_P_min" value="${Number(cfg.P_min)}"></label>
                    <label>P max <input type="number" id="pt_${name}_P_max" value="${Number(cfg.P_max)}"></label>
                    <label>Offset <input type="number" id="pt_${name}_offset" step="0.01" value="${Number(cfg.offset ?? 0)}"></label>
                </div>`;
            }
            html += '</div><div class="modal-section"><h3>RTDs</h3>';
            for (const [name, cfg] of Object.entries(data.rtds)) {
                const displayName = (cfg.display_name != null && cfg.display_name !== undefined) ? String(cfg.display_name) : '';
                const unit = (cfg.unit != null && cfg.unit !== undefined) ? String(cfg.unit) : '°C';
                const rtdUnitOpts = RTD_UNITS.map(u => `<option value="${u.value}" ${u.value === unit ? 'selected' : ''}>${u.label}</option>`).join('');
                html += `<div class="settings-row">
                    <label>${name}</label>
                    <label>Name <input type="text" class="display-name" id="rtd_${name}_display_name" placeholder="e.g. Fuel Line 1 Temp" value="${displayName.replace(/"/g, '&quot;')}"></label>
                    <label>Unit <select class="unit-select" id="rtd_${name}_unit">${rtdUnitOpts}</select></label>
                    <label><input type="checkbox" id="rtd_${name}_enabled" ${cfg.enabled ? 'checked' : ''}> Enabled</label>
                    <label>Offset <input type="number" id="rtd_${name}_offset" step="0.01" value="${Number(cfg.offset ?? 0)}"></label>
                </div>`;
            }
            html += '</div>';
            settingsFormContainer.innerHTML = html;
            // Store units from settings so graph value display uses selected unit
            for (const [name, cfg] of Object.entries(data.load_cells || {})) {
                sensorUnits[name] = (cfg.unit != null && cfg.unit !== undefined) ? String(cfg.unit) : 'lbf';
            }
            for (const [name, cfg] of Object.entries(data.pressure_transducers || {})) {
                sensorUnits[name] = (cfg.unit != null && cfg.unit !== undefined) ? String(cfg.unit) : 'Pa';
            }
            for (const [name, cfg] of Object.entries(data.rtds || {})) {
                sensorUnits[name] = (cfg.unit != null && cfg.unit !== undefined) ? String(cfg.unit) : '°C';
            }
            // Update unit when user changes dropdown (no save needed for live display)
            settingsFormContainer.querySelectorAll('select.unit-select').forEach((el) => {
                el.addEventListener('change', () => {
                    const m = el.id.match(/^(lc|pt|rtd)_(.+)_unit$/);
                    if (m) sensorUnits[m[2]] = el.value;
                    // Refresh value display if graph exists
                    if (sensorLabels.length > 0) {
                        sensorLabels.forEach((label) => {
                            const val = sensorCurrentValues[label];
                            const valueDisplay = document.getElementById(`value-${label}`);
                            if (valueDisplay != null && val != null && !isNaN(val)) {
                                const { decimals } = getSensorFormat(label);
                                valueDisplay.textContent = `${val.toFixed(decimals)} ${getDisplayUnit(label)}`;
                            }
                        });
                    }
                });
            });
            // Store display names so graph titles show "ID: name" when set
            sensorDisplayNames = {};
            for (const [name, cfg] of Object.entries(data.load_cells || {})) {
                sensorDisplayNames[name] = (cfg.display_name != null && cfg.display_name !== undefined) ? String(cfg.display_name).trim() : '';
            }
            for (const [name, cfg] of Object.entries(data.pressure_transducers || {})) {
                sensorDisplayNames[name] = (cfg.display_name != null && cfg.display_name !== undefined) ? String(cfg.display_name).trim() : '';
            }
            for (const [name, cfg] of Object.entries(data.rtds || {})) {
                sensorDisplayNames[name] = (cfg.display_name != null && cfg.display_name !== undefined) ? String(cfg.display_name).trim() : '';
            }
            // If graphs already exist, update their titles
            if (sensorLabels.length > 0) {
                sensorLabels.forEach((label) => {
                    const titleEl = document.getElementById(`title-${label}`);
                    if (titleEl && titleEl.firstChild) {
                        titleEl.firstChild.textContent = sensorDisplayNames[label] ? `${label}: ${sensorDisplayNames[label]}` : label;
                    }
                });
            }
            const slider = document.getElementById('adc_datarate_code');
            const valueSpan = document.getElementById('adc_datarate_value');
            if (slider && valueSpan) {
                slider.addEventListener('input', () => { valueSpan.textContent = slider.value; });
            }
            const sdCheck = document.getElementById('adc_settle_discard');
            const sdBtn = document.getElementById('adc_settle_discard_btn');
            if (sdCheck && sdBtn) {
                sdBtn.addEventListener('click', () => {
                    sdCheck.checked = !sdCheck.checked;
                    sdBtn.classList.toggle('enabled', sdCheck.checked);
                    sdBtn.classList.toggle('disabled', !sdCheck.checked);
                });
            }
        }

        // Collect form values into payload for POST /api/settings
        function collectSettingsPayload() {
            const load_cells = {};
            const pressure_transducers = {};
            const rtds = {};
            const drEl = document.getElementById('adc_datarate_code');
            const sdEl = document.getElementById('adc_settle_discard');
            const adc = {
                datarate_code: drEl ? Math.min(13, Math.max(0, parseInt(drEl.value, 10) || 0)) : 10,
                settle_discard: sdEl ? sdEl.checked : true
            };
            for (const el of document.querySelectorAll('[id^="lc_"]')) {
                const m = el.id.match(/^lc_(.+)_(enabled|sensitivity|max_load|display_name|unit|offset)$/);
                if (!m) continue;
                const [, name, key] = m;
                if (!load_cells[name]) load_cells[name] = {};
                if (key === 'enabled') load_cells[name].enabled = el.checked;
                else if (key === 'display_name') load_cells[name].display_name = (el.value && typeof el.value === 'string') ? el.value.trim() : '';
                else if (key === 'unit') load_cells[name].unit = (el.value && typeof el.value === 'string') ? el.value.trim() : 'lbf';
                else { const v = parseFloat(el.value); load_cells[name][key] = isNaN(v) ? 0 : v; }
            }
            for (const el of document.querySelectorAll('[id^="pt_"]')) {
                const m = el.id.match(/^pt_(.+)_(enabled|P_min|P_max|display_name|unit|offset)$/);
                if (!m) continue;
                const [, name, key] = m;
                if (!pressure_transducers[name]) pressure_transducers[name] = {};
                if (key === 'enabled') pressure_transducers[name].enabled = el.checked;
                else if (key === 'display_name') pressure_transducers[name].display_name = (el.value && typeof el.value === 'string') ? el.value.trim() : '';
                else if (key === 'unit') pressure_transducers[name].unit = (el.value && typeof el.value === 'string') ? el.value.trim() : 'Pa';
                else { const v = parseFloat(el.value); pressure_transducers[name][key] = isNaN(v) ? 0 : v; }
            }
            for (const el of document.querySelectorAll('[id^="rtd_"]')) {
                const m = el.id.match(/^rtd_(.+)_(enabled|display_name|unit|offset)$/);
                if (!m) continue;
                const [, name, key] = m;
                if (!rtds[name]) rtds[name] = {};
                if (key === 'enabled') rtds[name].enabled = el.checked;
                else if (key === 'display_name') rtds[name].display_name = (el.value && typeof el.value === 'string') ? el.value.trim() : '';
                else if (key === 'unit') rtds[name].unit = (el.value && typeof el.value === 'string') ? el.value.trim() : '°C';
                else { const v = parseFloat(el.value); rtds[name][key] = isNaN(v) ? 0 : v; }
            }
            return { adc, load_cells, pressure_transducers, rtds };
        }

        async function fetchAndPopulateSettings() {
            try {
                const res = await fetch('/api/settings');
                if (res.ok) {
                    const data = await res.json();
                    buildSettingsForm(data);
                }
            } catch (e) {
                console.error('Failed to fetch settings:', e);
            }
        }

        document.getElementById('settings-button').addEventListener('click', () => {
            fetchAndPopulateSettings();
            settingsModal.classList.add('open');
            settingsModal.setAttribute('aria-hidden', 'false');
        });

        settingsCancelBtn.addEventListener('click', () => {
            settingsModal.classList.remove('open');
            settingsModal.setAttribute('aria-hidden', 'true');
        });

        settingsModal.addEventListener('click', (e) => {
            if (e.target === settingsModal) {
                settingsModal.classList.remove('open');
                settingsModal.setAttribute('aria-hidden', 'true');
            }
        });

        settingsSaveBtn.addEventListener('click', async () => {
            const payload = collectSettingsPayload();
            try {
                const res = await fetch('/api/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await res.json().catch(() => ({}));
                if (res.ok) {
                    settingsSavedMsg.textContent = 'Saved. Restarting...';
                    settingsSavedMsg.classList.add('show');
                    setTimeout(() => {
                        settingsSavedMsg.classList.remove('show');
                        settingsSavedMsg.textContent = 'Saved. Restarting...';
                        settingsModal.classList.remove('open');
                        settingsModal.setAttribute('aria-hidden', 'true');
                    }, 2000);
                } else {
                    alert(data.error || 'Failed to save settings');
                }
            } catch (e) {
                console.error('Save settings error:', e);
                alert('Failed to save settings');
            }
        });

        // Load settings on page load so form is ready when user opens modal
        fetchAndPopulateSettings();

        // Connection status handlers
        socket.on('connect', () => {
            console.log('Connected to server');
            connectionIndicator.classList.remove('disconnected');
            connectionIndicator.classList.add('connected');
            if (connectionText) {
                connectionText.textContent = 'online';
            }
        });
        
        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            connectionIndicator.classList.remove('connected');
            connectionIndicator.classList.add('disconnected');
            if (connectionText) {
                connectionText.textContent = 'offline';
            }
        });
        
        socket.on('connected', (data) => {
            console.log('Server confirmed connection:', data);
        });
        
        // System info DOM elements
        const systemInfoContainer = document.getElementById('system-info');
        const systemInfoCompact = document.getElementById('system-info-compact');
        
        // System info handler
        socket.on('system_info', (data) => {
            if (!data) return;
            
            // Show system info container
            if (systemInfoContainer) {
                systemInfoContainer.style.display = 'block';
            }
            
            // Update compact view
            const cpuTempEl = document.getElementById('sys-cpu-temp');
            const ramUsedEl = document.getElementById('sys-ram-used');
            const ramTotalEl = document.getElementById('sys-ram-total');
            const cpuUseEl = document.getElementById('sys-cpu-use');
            const diskPercentEl = document.getElementById('sys-disk-percent');
            
            if (cpuTempEl && data.cpu_temp) {
                cpuTempEl.textContent = data.cpu_temp;
            }
            if (ramUsedEl && data.ram && data.ram.used) {
                ramUsedEl.textContent = data.ram.used;
            }
            if (ramTotalEl && data.ram && data.ram.total) {
                ramTotalEl.textContent = data.ram.total;
            }
            if (cpuUseEl && data.cpu_use) {
                cpuUseEl.textContent = data.cpu_use;
            }
            if (diskPercentEl && data.disk && data.disk.percent) {
                diskPercentEl.textContent = data.disk.percent;
            }
            
            // Update expanded view
            const detailCpuTemp = document.getElementById('sys-detail-cpu-temp');
            const detailRamTotal = document.getElementById('sys-detail-ram-total');
            const detailRamUsed = document.getElementById('sys-detail-ram-used');
            const detailRamFree = document.getElementById('sys-detail-ram-free');
            const detailCpuUse = document.getElementById('sys-detail-cpu-use');
            const detailDiskTotal = document.getElementById('sys-detail-disk-total');
            const detailDiskUsed = document.getElementById('sys-detail-disk-used');
            const detailDiskFree = document.getElementById('sys-detail-disk-free');
            const detailDiskPercent = document.getElementById('sys-detail-disk-percent');
            
            if (detailCpuTemp && data.cpu_temp) {
                detailCpuTemp.textContent = data.cpu_temp + '°C';
            }
            if (detailRamTotal && data.ram && data.ram.total) {
                detailRamTotal.textContent = data.ram.total;
            }
            if (detailRamUsed && data.ram && data.ram.used) {
                detailRamUsed.textContent = data.ram.used;
            }
            if (detailRamFree && data.ram && data.ram.free) {
                detailRamFree.textContent = data.ram.free;
            }
            if (detailCpuUse && data.cpu_use) {
                detailCpuUse.textContent = data.cpu_use + '%';
            }
            if (detailDiskTotal && data.disk && data.disk.total) {
                detailDiskTotal.textContent = data.disk.total;
            }
            if (detailDiskUsed && data.disk && data.disk.used) {
                detailDiskUsed.textContent = data.disk.used;
            }
            if (detailDiskFree && data.disk && data.disk.free) {
                detailDiskFree.textContent = data.disk.free;
            }
            if (detailDiskPercent && data.disk && data.disk.percent) {
                detailDiskPercent.textContent = data.disk.percent;
            }
        });
        
        // Expand/collapse system info on click
        if (systemInfoContainer) {
            systemInfoContainer.addEventListener('click', () => {
                systemInfoContainer.classList.toggle('expanded');
            });
        }
        
        // Sensor data handler
        socket.on('sensor_data', (data) => {
            if (!data.labels || !data.values || !Array.isArray(data.labels) || !Array.isArray(data.values)) {
                console.warn('Invalid sensor data received:', data);
                return;
            }
            
            // Debug: log first few data packets
            if (!sensorLabels.length || Math.random() < 0.01) {
                console.log('Received sensor_data:', { 
                    labels: data.labels, 
                    values: data.values, 
                    time: data.time,
                    numLabels: data.labels.length,
                    numValues: data.values.length 
                });
            }
            
            // Initialize on first data
            if (sensorLabels.length === 0) {
                sensorLabels = data.labels;
                console.log('Initializing graphs for sensors:', sensorLabels);
                initializeGraphs();
                // Resize canvases and start streaming after graphs are created
                setTimeout(() => {
                    resizeCanvases();
                    // Start streaming after canvas is sized
                    sensorLabels.forEach((label) => {
                        const canvas = document.getElementById(`canvas-${label}`);
                        const chart = sensorCharts[label];
                        if (canvas && chart) {
                            // Ensure canvas has valid dimensions
                            if (canvas.width > 0 && canvas.height > 0) {
                                chart.streamTo(canvas, 100);
                                console.log('Started streaming for:', label, 'canvas size:', canvas.width, 'x', canvas.height);
                            } else {
                                console.warn('Canvas not properly sized for:', label, 'retrying...');
                                // Retry after a short delay
                                setTimeout(() => {
                                    resizeCanvases();
                                    if (canvas.width > 0 && canvas.height > 0) {
                                        chart.streamTo(canvas, 100);
                                        console.log('Started streaming for:', label, 'after retry');
                                    }
                                }, 100);
                            }
                        }
                    });
                }, 200);
            }
            
            // Update each sensor's time series (only if graphs are initialized)
            if (sensorLabels.length > 0 && Object.keys(sensorTimeSeries).length > 0) {
                data.labels.forEach((label, index) => {
                    if (sensorTimeSeries[label] && data.values[index] !== undefined && !isNaN(data.values[index])) {
                        const value = parseFloat(data.values[index]);
                        
                        // Use current timestamp for Smoothie.js (it handles the time window automatically)
                        const timestamp = Date.now();
                        
                        // Update time series
                        try {
                            sensorTimeSeries[label].append(timestamp, value);
                            
                            // Update current value display
                            sensorCurrentValues[label] = value;
                            const valueDisplay = document.getElementById(`value-${label}`);
                            if (valueDisplay) {
                                const { decimals } = getSensorFormat(label);
                                valueDisplay.textContent = `${value.toFixed(decimals)} ${getDisplayUnit(label)}`;
                                // Set color to match graph line
                                if (sensorColors[label]) {
                                    valueDisplay.style.color = sensorColors[label];
                                }
                            }
                            
                            // Debug logging (first sensor, occasional)
                            if (index === 0 && Math.random() < 0.05) {
                                console.log('Appended data:', { label, value, timestamp, chartExists: !!sensorCharts[label] });
                            }
                        } catch (error) {
                            console.error('Error appending to TimeSeries:', error, { label, value, timestamp });
                        }
                    
                        // Track min/max for auto-scaling
                        if (!sensorMinMax[label]) {
                            sensorMinMax[label] = { min: value, max: value };
                            // Set initial range
                            const chart = sensorCharts[label];
                            if (chart && chart.options) {
                                const padding = Math.abs(value) * 0.1 || 1;
                                chart.options.minValue = value - padding;
                                chart.options.maxValue = value + padding;
                            }
                        } else {
                            const oldMin = sensorMinMax[label].min;
                            const oldMax = sensorMinMax[label].max;
                            sensorMinMax[label].min = Math.min(sensorMinMax[label].min, value);
                            sensorMinMax[label].max = Math.max(sensorMinMax[label].max, value);
                            
                            // Only update if value is outside current range or range changed significantly
                            const padding = (sensorMinMax[label].max - sensorMinMax[label].min) * 0.1 || 1;
                            const newMin = sensorMinMax[label].min - padding;
                            const newMax = sensorMinMax[label].max + padding;
                            
                            const chart = sensorCharts[label];
                            if (chart && chart.options) {
                                const currentMin = chart.options.minValue || 0;
                                const currentMax = chart.options.maxValue || 100;
                                
                                // Update if value is outside current range or range changed by more than 5%
                                const rangeChange = Math.abs((newMax - newMin) - (currentMax - currentMin));
                                const rangePercent = rangeChange / Math.max(Math.abs(currentMax - currentMin), 1) * 100;
                                
                                if (value < currentMin || value > currentMax || rangePercent > 5) {
                                    chart.options.minValue = newMin;
                                    chart.options.maxValue = newMax;
                                }
                            }
                        }
                    }
                });
            }
        });
        
        // Initialize graphs based on sensor labels
        function initializeGraphs() {
            const numSensors = sensorLabels.length;
            if (numSensors === 0) return;
            
            // Determine grid layout
            let cols, rows;
            if (numSensors === 1) {
                cols = 1;
                rows = 1;
            } else if (numSensors <= 4) {
                cols = 2;
                rows = Math.ceil(numSensors / 2);
            } else {
                cols = 3;
                rows = Math.ceil(numSensors / 3);
            }
            
            graphsContainer.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            graphsContainer.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
            
            // Create graph for each sensor
            sensorLabels.forEach((label, index) => {
                // Create container
                const container = document.createElement('div');
                container.className = 'graph-container rounded p-2';
                container.style.backgroundColor = '#000000';
                container.id = `graph-${label}`;
                container.style.display = 'flex';
                container.style.flexDirection = 'column';
                container.style.height = '100%';
                
                // Create title with value display
                const title = document.createElement('div');
                title.className = 'text-white text-sm font-semibold mb-1 flex justify-between items-center';
                title.id = `title-${label}`;
                const titleText = document.createElement('span');
                titleText.textContent = sensorDisplayNames[label] ? `${label}: ${sensorDisplayNames[label]}` : label;
                const valueDisplay = document.createElement('span');
                valueDisplay.id = `value-${label}`;
                valueDisplay.className = 'font-normal';
                valueDisplay.textContent = '--';
                title.appendChild(titleText);
                title.appendChild(valueDisplay);
                container.appendChild(title);
                
                // Create canvas
                const canvas = document.createElement('canvas');
                canvas.id = `canvas-${label}`;
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                container.appendChild(canvas);
                
                graphsContainer.appendChild(container);
                
                // Create TimeSeries first
                const timeSeries = new TimeSeries();
                
                // Create SmoothieChart - we'll update minValue/maxValue dynamically
                const smoothieChart = new SmoothieChart({
                    grid: {
                        strokeStyle: 'rgba(255, 255, 255, 0.1)',
                        lineWidth: 1,
                        millisPerLine: 1000,
                        verticalSections: 4
                    },
                    labels: {
                        fillStyle: 'rgba(255, 255, 255, 0.8)',
                        fontSize: 10
                    },
                    tooltip: true,
                    responsive: true,
                    millisPerPixel: 10,
                    timestampFormatter: SmoothieChart.timeFormatter,
                    minValue: 0,
                    maxValue: 100
                });
                
                // Assign color from COLOR_LIST (cycle through if more sensors than colors)
                const colorIndex = index % COLOR_LIST.length;
                const lineColor = COLOR_LIST[colorIndex];
                
                smoothieChart.addTimeSeries(timeSeries, {
                    strokeStyle: lineColor,
                    lineWidth: 2
                });
                
                // Store references BEFORE streaming
                sensorCharts[label] = smoothieChart;
                sensorTimeSeries[label] = timeSeries;
                sensorMinMax[label] = null;
                sensorCurrentValues[label] = null;
                sensorColors[label] = lineColor; // Store color for value display
                
                // Set initial color for value display
                if (valueDisplay) {
                    valueDisplay.style.color = lineColor;
                }
            });
        }
        
        // Handle window resize
        let resizeTimeout;
        function resizeCanvases() {
            sensorLabels.forEach((label) => {
                const canvas = document.getElementById(`canvas-${label}`);
                const container = document.getElementById(`graph-${label}`);
                if (canvas && container) {
                    // Get container dimensions
                    const rect = container.getBoundingClientRect();
                    const title = container.querySelector('div');
                    const titleHeight = title ? title.offsetHeight + 8 : 0; // title height + margin
                    const labelSpace = 25; // Space needed for bottom labels
                    // Set canvas size to match container (accounting for padding, title, and labels)
                    const padding = 16; // 8px on each side
                    const width = Math.max(1, rect.width - padding);
                    const height = Math.max(1, rect.height - titleHeight - padding - labelSpace);
                    // Set actual canvas dimensions (not just CSS)
                    canvas.width = width;
                    canvas.height = height;
                }
            });
        }
        
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(resizeCanvases, 100);
        });
        
        // Download button handler
        downloadButton.addEventListener('click', async () => {
            if (!currentFileName) return;
            
            try {
                const response = await fetch(`/data/${currentFileName}`);
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = currentFileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                } else {
                    alert('Failed to download file');
                }
            } catch (error) {
                console.error('Download error:', error);
                alert('Error downloading file');
            }
        });
        
        // Fetch current file name periodically
        async function updateCurrentFile() {
            try {
                const response = await fetch('/api/current-file');
                if (response.ok) {
                    const data = await response.json();
                    if (data.exists && data.filename) {
                        currentFileName = data.filename;
                        downloadButton.disabled = false;
                    } else {
                        currentFileName = null;
                        downloadButton.disabled = true;
                    }
                }
            } catch (error) {
                console.error('Error fetching current file:', error);
            }
        }
        
        // Update current file every 2 seconds
        setInterval(updateCurrentFile, 2000);
        updateCurrentFile();
    </script>
</body>
</html>

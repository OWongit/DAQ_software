<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAQ Monitor</title>
    <link rel="icon" href="/images/favicon.png" type="image/png">
    <!-- Tailwind CSS for styling -->
    <script src="/static/vendor/tailwind.js"></script>
    <!-- Smoothie.js for real-time graphs -->
    <script src="/static/vendor/smoothie.min.js"></script>
    <!-- Socket.IO client -->
    <script src="/static/vendor/socket.io.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100vh;
            background-color: #000000;
        }
        .graph-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-sizing: border-box;
            padding-bottom: 25px; /* Space for bottom labels */
        }
        .graph-container canvas {
            display: block;
            width: 100%;
            flex: 1;
            min-height: 0;
            box-sizing: border-box;
        }
        .connection-status {
            position: fixed;
            top: 17px;
            left: 10px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .connection-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .connection-indicator.connected {
            background-color: #22c55e;
            box-shadow: 0 0 12px rgba(34, 197, 94, 0.8), 0 0 24px rgba(34, 197, 94, 0.4);
        }
        .connection-indicator.disconnected {
            background-color: #ef4444;
        }
        .connection-text {
            color: white;
            font-size: 11px;
            font-weight: 500;
        }
        .download-button {
            padding: 8px 8px;
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: background-color 0.2s;
        }
        .download-button:hover {
            background-color: #2563eb;
        }
        .download-button:disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
        }
        .download-dropdown-wrap {
            position: relative;
        }
        .download-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            min-width: 260px;
            max-width: 360px;
            max-height: 320px;
            overflow-y: auto;
            background-color: rgba(20, 20, 20, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 1100;
        }
        .download-dropdown.open {
            display: block;
        }
        .download-dropdown-title {
            padding: 10px 12px;
            color: #e5e7eb;
            font-size: 12px;
            font-weight: 600;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .download-dropdown-list {
            padding: 6px 0;
        }
        .download-dropdown-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            padding: 8px 12px;
            color: #d1d5db;
            font-size: 11px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        }
        .download-dropdown-item:last-child {
            border-bottom: none;
        }
        .download-dropdown-item .filename {
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .download-dropdown-item .current-badge {
            flex-shrink: 0;
            color: #22c55e;
            font-size: 10px;
            font-weight: 600;
        }
        .download-dropdown-item button {
            flex-shrink: 0;
            padding: 4px 10px;
            font-size: 11px;
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .download-dropdown-item button:hover {
            background-color: #2563eb;
        }
        .download-dropdown-empty {
            padding: 16px 12px;
            color: #9ca3af;
            font-size: 12px;
        }
        .system-info {
            position: fixed;
            top: 11px;
            left: 70px;
            z-index: 1000;
            background-color: rgba(56, 56, 56, 0.9);
            border-radius: 6px;
            padding: 6px 10px;
            cursor: pointer;
            transition: background-color 0.2s;
            max-width: calc(100vw - 250px);
        }
        .system-info:hover {
            background-color: rgb(36, 36, 36);
        }
        .system-info-compact {
            color: white;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }
        .system-info-compact span {
            color: rgba(255, 255, 255, 0.8);
        }
        .system-info-expanded {
            display: none;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 10px;
        }
        .system-info.expanded .system-info-expanded {
            display: block;
        }
        .system-info-expanded div {
            margin: 4px 0;
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }
        .system-info-expanded .label {
            color: rgba(255, 255, 255, 0.6);
        }
        .system-info-expanded .value {
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
        }
        .top-right-actions {
            position: fixed;
            top: 7px;
            right: 10px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .settings-button {
            padding: 8px;
            background-color: rgba(56, 56, 56, 0.9);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }
        .settings-button:hover {
            background-color: rgb(36, 36, 36);
        }
        .settings-button svg {
            width: 20px;
            height: 20px;
        }
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        .modal-overlay.open {
            display: flex;
        }
        .modal-box {
            background-color: #0a0a0a;
            border-radius: 10px;
            padding: 24px;
            max-width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.8), 0 0 0 1px rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .modal-box h2 {
            color: #fff;
            font-size: 20px;
            font-weight: 600;
            margin: 0 0 16px 0;
            letter-spacing: 0.02em;
        }
        .modal-intro {
            color: #b4b8bc;
            font-size: 12px;
            margin: 0 0 16px 0;
        }
        .modal-section {
            margin-bottom: 24px;
        }
        .modal-section h3 {
            color: #e5e7eb;
            font-size: 14px;
            font-weight: 600;
            margin: 0 0 12px 0;
            letter-spacing: 0.03em;
        }
        .settings-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }
        .settings-row label {
            color: #d1d5db;
            font-size: 12px;
            font-weight: 500;
            min-width: 80px;
        }
        .settings-row input[type="number"] {
            width: 90px;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: #171717;
            color: #fff;
        }
        .settings-row input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            transition: box-shadow 0.2s;
        }
        .settings-row input[type="checkbox"]:checked {
            box-shadow: 0 0 14px rgba(34, 197, 94, 0.7), 0 0 24px rgba(34, 197, 94, 0.35);
        }

        .settings-row input[type="text"].display-name {
            flex: 1;
            min-width: 120px;
            max-width: 200px;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: #171717;
            color: #fff;
            font-size: 12px;
        }
        .settings-row select.unit-select {
            min-width: 90px;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: #171717;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
        }
        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 7px;
            justify-content: space-between;
            align-items: center;
        }
        .modal-actions button {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            border: none;
        }
        .modal-actions .btn-save {
            background-color: #2563eb;
            color: white;
            font-weight: 600;
        }
        .modal-actions .btn-save:hover {
            background-color: #3b82f6;
            box-shadow: 0 0 16px rgba(59, 130, 246, 0.4);
        }
        .modal-actions .btn-cancel {
            background-color: #374151;
            color: #e5e7eb;
        }
        .modal-actions .btn-cancel:hover {
            background-color: #4b5563;
        }
        .settings-saved-msg {
            color: #22c55e;
            font-size: 12px;
            margin-left: 10px;
            display: none;
        }
        .settings-saved-msg.show {
            display: inline;
        }
        .settings-warning {
            display: block;
            color: #fbbf24;
            font-size: 11px;
            margin-bottom: 8px;
            font-weight: 600;
        }
        .modal-reboot {
            margin-top: 10px;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 10px;
        }
        .modal-reboot button {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            border: none;
            font-weight: 600;
        }
        #settings-reboot {
            background-color: #fbbf24;
            color: #000;
        }
        #settings-reboot:hover {
            background-color: #f59e0b;
            box-shadow: 0 0 14px rgba(251, 191, 36, 0.6);
        }
        #settings-shutdown {
            background-color: #b91c1c;
            color: #fee2e2;
        }
        #settings-shutdown:hover {
            background-color: #dc2626;
            box-shadow: 0 0 14px rgba(248, 113, 113, 0.6);
        }
        .adc-slider-row {
            display: flex;
            align-items: center;
            gap: 14px;
            margin-bottom: 10px;
        }
        .adc-slider-row label {
            color: #f3f4f6;
            font-size: 13px;
            font-weight: 600;
            min-width: auto;
        }
        .adc-slider-row input[type="range"] {
            width: 120px;
            accent-color: #3b82f6;
        }
        #adc_datarate_value {
            color: #60a5fa;
            font-weight: 600;
            font-size: 14px;
            min-width: 24px;
        }
        .settings-explanation {
            color: #9ca3af;
            font-size: 11px;
            margin: 4px 0 12px 0;
            max-width: 480px;
        }
        .settle-discard-toggle {
            padding: 8px 18px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        .settle-discard-toggle.enabled {
            background-color: #22c55e;
            color: white;
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.6), 0 0 40px rgba(34, 197, 94, 0.3);
        }
        .settle-discard-toggle.enabled:hover {
            box-shadow: 0 0 24px rgba(34, 197, 94, 0.7), 0 0 48px rgba(34, 197, 94, 0.35);
        }
        .settle-discard-toggle.disabled {
            background-color: #4b5563;
            color: #d1d5db;
        }
        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background-color: rgba(20, 20, 20, 0.95);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 999;
        }
        .bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background-color: rgba(20, 20, 20, 0.95);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 5px;
            z-index: 999;
        }
        .bottom-bar-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .bottom-bar-left img {
            height: 28px;
            width: auto;
            display: block;
        }
        .bottom-bar-left .daq-label {
            color: #e5e7eb;
            font-size: 16px;
            font-weight: 600;
            letter-spacing: 0.05em;
        }
        .bottom-bar-center {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
        }
        .bottom-bar-right {
            color: rgba(255, 255, 255, 0.85);
            font-size: 13px;
            font-weight: 500;
            font-variant-numeric: tabular-nums;
        }
        .config-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 18px;
            padding: 14px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            background: #111;
        }
        .config-section-row {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .config-file-label {
            color: #9ca3af;
            font-size: 12px;
        }
        .config-file-name {
            color: #60a5fa;
            font-weight: 600;
            font-size: 12px;
        }
        .config-upload-btn,
        .config-download-btn {
            padding: 6px 14px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s;
        }
        .config-upload-btn {
            background-color: #6366f1;
            color: white;
        }
        .config-upload-btn:hover {
            background-color: #818cf8;
        }
        .config-download-btn {
            background-color: #0d9488;
            color: white;
        }
        .config-download-btn:hover {
            background-color: #14b8a6;
        }
        .config-upload-warning {
            color: #fbbf24;
            font-size: 11px;
            font-weight: 600;
        }
        .no-displays-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #e5e7eb;
            font-size: 11px;
            font-weight: 500;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- Top bar (same background as bottom bar) -->
    <div class="top-bar"></div>
    <!-- Connection Status Indicator -->
    <div class="connection-status">
        <div id="connection-indicator" class="connection-indicator disconnected"></div>
        <span id="connection-text" class="connection-text">offline</span>
    </div>
    
    <!-- System Info Display -->
    <div id="system-info" class="system-info" style="display: none;">
        <div class="system-info-compact" id="system-info-compact">
            <span>CPU: <span id="sys-cpu-temp">--</span>°C</span>
            <span>|</span>
            <span>RAM: <span id="sys-ram-used">--</span>/<span id="sys-ram-total">--</span></span>
            <span>|</span>
            <span>CPU: <span id="sys-cpu-use">--</span>%</span>
            <span>|</span>
            <span>Disk: <span id="sys-disk-percent">--</span></span>
        </div>
        <div class="system-info-expanded">
            <div>
                <span class="label">CPU Temperature:</span>
                <span class="value" id="sys-detail-cpu-temp">--</span>
            </div>
            <div>
                <span class="label">RAM Total:</span>
                <span class="value" id="sys-detail-ram-total">--</span>
            </div>
            <div>
                <span class="label">RAM Used:</span>
                <span class="value" id="sys-detail-ram-used">--</span>
            </div>
            <div>
                <span class="label">RAM Free:</span>
                <span class="value" id="sys-detail-ram-free">--</span>
            </div>
            <div>
                <span class="label">CPU Usage:</span>
                <span class="value" id="sys-detail-cpu-use">--</span>
            </div>
            <div>
                <span class="label">Disk Total:</span>
                <span class="value" id="sys-detail-disk-total">--</span>
            </div>
            <div>
                <span class="label">Disk Used:</span>
                <span class="value" id="sys-detail-disk-used">--</span>
            </div>
            <div>
                <span class="label">Disk Free:</span>
                <span class="value" id="sys-detail-disk-free">--</span>
            </div>
            <div>
                <span class="label">Disk Usage:</span>
                <span class="value" id="sys-detail-disk-percent">--</span>
            </div>
        </div>
    </div>
    
    <!-- Top right: Settings gear + Download -->
    <div class="top-right-actions">
        <button id="settings-button" class="settings-button" title="Settings" aria-label="Settings">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"/>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
            </svg>
        </button>
        <div class="download-dropdown-wrap">
            <button id="download-button" class="download-button" type="button">
                Download CSV
            </button>
            <div id="download-dropdown" class="download-dropdown" aria-hidden="true">
                <div class="download-dropdown-title">CSV data files</div>
                <div id="download-dropdown-list" class="download-dropdown-list"></div>
                <div id="download-dropdown-empty" class="download-dropdown-empty" style="display: none;">No CSV files yet.</div>
            </div>
        </div>
    </div>

    <!-- Settings modal -->
    <div id="settings-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal-box">
            <h2>Settings</h2>
            <p class="modal-intro">Settings are kept in memory only and are not saved across reboots. Upload a config file or set values manually each session.</p>
            <div class="config-section">
                <div class="config-section-row">
                    <span class="config-file-label">Current config:</span>
                    <span id="config-file-name" class="config-file-name">defaults</span>
                </div>
                <div class="config-section-row">
                    <button type="button" id="config-upload-btn" class="config-upload-btn">Upload config file</button>
                    <input type="file" id="config-upload-input" accept=".json" style="display:none">
                    <button type="button" id="config-download-btn" class="config-download-btn">Download current config</button>
                </div>
                <span class="config-upload-warning">WARNING: UPLOADING A CONFIG FILE WILL APPLY SETTINGS AND CREATE A NEW CSV DATA LOG FILE.</span>
            </div>
            <div id="settings-form-container"></div>
            <div style="text-align: right;">
                <span class="settings-warning">WARNING: APPLYING SETTINGS WILL CREATE A NEW CSV DATA LOG FILE.</span>
            </div>
            <div class="modal-actions">
                <div class="modal-reboot">
                    <button id="settings-reboot">REBOOT</button>
                    <button id="settings-shutdown">SHUTDOWN</button>
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span id="settings-saved-msg" class="settings-saved-msg">Saved. Restarting...</span>
                    <button id="settings-cancel" class="btn-cancel">Cancel</button>
                    <button id="settings-save" class="btn-save">Save and RESTART</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Graph Grid Container -->
    <div id="graphs-container" class="w-full h-screen grid gap-2 p-2" style="grid-auto-rows: 1fr; overflow: hidden; box-sizing: border-box; padding-top: 50px; padding-bottom: 40px;"></div>
    <div id="no-displays-message" class="no-displays-message" style="display: none;">
        No active displays. Enable via Settings.
    </div>

    <!-- Bottom bar -->
    <div class="bottom-bar">
        <div class="bottom-bar-left">
            <img src="/images/SARP_LOGO_MK2.png" alt="">
            <span class="daq-label">Data Acquisition System</span>
        </div>
        <div class="bottom-bar-center">© Society for Advanced Rocket Propulsion (SARP)</div>
        <div class="bottom-bar-right"><span id="bottom-bar-time"></span></div>
    </div>

    <script>
        // Bottom bar time (far right)
        function updateBottomBarTime() {
            const el = document.getElementById('bottom-bar-time');
            if (el) el.textContent = new Date().toLocaleTimeString();
        }
        updateBottomBarTime();
        setInterval(updateBottomBarTime, 1000);

        // SocketIO connection
        const socket = io();
        
        // Color list for sensor graphs
        const COLOR_LIST = [
            '#bbbbbb', 
            "#ff0000", 
            "#ff6200", 
            "#ffcc00", 
            "#80ff00",
            "#00ff7b", 
            "#00f2ff", 
            "#0077ff", 
            "#9000ff", 
            "#e600ff", 
            "#ff006a"
        ];
        
        // State
        let sensorCharts = {};
        let sensorTimeSeries = {};
        let sensorMinMax = {};
        let sensorCurrentValues = {}; // Store current values for display
        let sensorColors = {}; // Store line color for each sensor
        let sensorLabels = [];
        let sensorDisplayNames = {}; // Display names from settings (e.g. LC1 -> "Strain Gauge 1")
        let sensorUnits = {}; // Selected unit per sensor (e.g. LC1 -> "lbf"); falls back to getSensorFormat().unit

        // ADS124S08 nominal data rates for DATARATE_CODE 0–13 (Hz)
        const ADC_DATARATE_SPS = {
            0: 2.5,
            1: 5,
            2: 10,
            3: 16.6,
            4: 20,
            5: 50,
            6: 60,
            7: 100,
            8: 200,
            9: 400,
            10: 800,
            11: 1000,
            12: 2000,
            13: 4000
        };
        
        // Unit options (must match backend config.LOAD_CELL_UNITS / PRESSURE_UNITS / RTD_UNITS)
        const LOAD_CELL_UNITS = [
            { value: 'N', label: 'N' },
            { value: 'kN', label: 'kN' },
            { value: 'lbf', label: 'lbf' },
            { value: 'gf', label: 'gf' },
            { value: 'kgf', label: 'kgf' }
        ];
        const PRESSURE_UNITS = [
            { value: 'psi', label: 'psi' },
            { value: 'Pa', label: 'Pa' },
            { value: 'kPa', label: 'kPa' },
            { value: 'bar', label: 'bar' },
            { value: 'mbar', label: 'mbar' }
        ];
        const RTD_UNITS = [
            { value: '°C', label: '°C' },
            { value: '°F', label: '°F' },
            { value: 'K', label: 'K' }
        ];
        
        // Helper: unit and decimal places for sensor type (defaults; overridden by sensorUnits when user selects)
        function getSensorFormat(label) {
            if (label.startsWith('LC')) return { unit: 'lbf', decimals: 2 };
            if (label.startsWith('PT')) return { unit: 'Pa', decimals: 2 };
            if (label.startsWith('RTD')) return { unit: '°C', decimals: 1 };
            return { unit: '', decimals: 1 };
        }
        function getDisplayUnit(label) {
            return sensorUnits[label] != null && sensorUnits[label] !== '' ? sensorUnits[label] : getSensorFormat(label).unit;
        }
        
        // DOM elements
        const connectionIndicator = document.getElementById('connection-indicator');
        const connectionText = document.getElementById('connection-text');
        const downloadButton = document.getElementById('download-button');
        const graphsContainer = document.getElementById('graphs-container');
        const settingsModal = document.getElementById('settings-modal');
        const settingsFormContainer = document.getElementById('settings-form-container');
        const settingsSaveBtn = document.getElementById('settings-save');
        const settingsCancelBtn = document.getElementById('settings-cancel');
        const settingsSavedMsg = document.getElementById('settings-saved-msg');
        const settingsRebootBtn = document.getElementById('settings-reboot');
        const settingsShutdownBtn = document.getElementById('settings-shutdown');
        const noDisplaysMessage = document.getElementById('no-displays-message');

        function setNoDisplaysVisible(on) {
            if (!noDisplaysMessage) return;
            noDisplaysMessage.style.display = on ? 'block' : 'none';
        }

        // Build settings form from API data and inject into container
        function buildSettingsForm(data) {
            if (!data || !data.load_cells || !data.pressure_transducers || !data.rtds) return;
            const adc = data.adc || { datarate_code: 10, settle_discard: true };
            const dr = Math.min(13, Math.max(0, parseInt(adc.datarate_code, 10) || 10));
            const sdInitial = !!adc.settle_discard;

            let html = '';

            // Determine how many sensors are enabled in settings
            let enabledCountFromSettings = 0;
            for (const cfg of Object.values(data.load_cells || {})) {
                if (cfg && cfg.enabled) enabledCountFromSettings += 1;
            }
            for (const cfg of Object.values(data.pressure_transducers || {})) {
                if (cfg && cfg.enabled) enabledCountFromSettings += 1;
            }
            for (const cfg of Object.values(data.rtds || {})) {
                if (cfg && cfg.enabled) enabledCountFromSettings += 1;
            }
            setNoDisplaysVisible(enabledCountFromSettings === 0);
            html += '<div class="modal-section"><h3>ADC</h3>';
            html += '<div class="adc-slider-row"><label>Data rate (0–13)</label><input type="range" id="adc_datarate_code" min="0" max="13" value="' + dr + '"><span id="adc_datarate_value">' + dr + '</span></div>';
            html += '<p id="adc_rate_summary" class="settings-explanation"></p>';
            html += '<p class="settings-explanation">ADS124S08 data rate / filter. Higher = faster, noisier; lower = slower, quieter. 0=slow, 13=fastest.</p>';
            html += '<div class="adc-slider-row"><label>Settle discard</label>';
            html += '<input type="checkbox" id="adc_settle_discard" ' + (sdInitial ? 'checked' : '') + ' style="display:none">';
            html += '<button type="button" id="adc_settle_discard_btn" class="settle-discard-toggle ' + (sdInitial ? 'enabled' : 'disabled') + '">Enabled</button></div>';
            html += '<p class="settings-explanation">When enabled, discard one conversion per channel read for more stable readings (slower). When disabled, use one conversion per read (faster, may have small step response).</p>';
            html += '</div>';
            html += '<div class="modal-section"><h3>Load cells</h3>';
            for (const [name, cfg] of Object.entries(data.load_cells)) {
                const displayName = (cfg.display_name != null && cfg.display_name !== undefined) ? String(cfg.display_name) : '';
                const unit = (cfg.unit != null && cfg.unit !== undefined) ? String(cfg.unit) : 'lbf';
                const lcUnitOpts = LOAD_CELL_UNITS.map(u => `<option value="${u.value}" ${u.value === unit ? 'selected' : ''}>${u.label}</option>`).join('');
                html += `<div class="settings-row">
                    <label>${name}</label>
                    <label>Label <input type="text" class="display-name" id="lc_${name}_display_name" value="${displayName.replace(/"/g, '&quot;')}"></label>
                    <label>Unit <select class="unit-select" id="lc_${name}_unit">${lcUnitOpts}</select></label>
                    <label><input type="checkbox" id="lc_${name}_enabled" ${cfg.enabled ? 'checked' : ''}> Enabled</label>
                    <label>Sensitivity <input type="number" id="lc_${name}_sensitivity" step="0.001" value="${Number(cfg.sensitivity)}"></label>
                    <label>Max load <input type="number" id="lc_${name}_max_load" step="0.01" value="${Number(cfg.max_load)}"></label>
                    <label>Offset <input type="number" id="lc_${name}_offset" step="0.01" value="${Number(cfg.offset ?? 0)}"></label>
                </div>`;
            }
            html += '</div><div class="modal-section"><h3>Pressure transducers (5V)</h3>';
            for (const [name, cfg] of Object.entries(data.pressure_transducers)) {
                const displayName = (cfg.display_name != null && cfg.display_name !== undefined) ? String(cfg.display_name) : '';
                const unit = (cfg.unit != null && cfg.unit !== undefined) ? String(cfg.unit) : 'Pa';
                const ptUnitOpts = PRESSURE_UNITS.map(u => `<option value="${u.value}" ${u.value === unit ? 'selected' : ''}>${u.label}</option>`).join('');
                html += `<div class="settings-row">
                    <label>${name}</label>
                    <label>Label <input type="text" class="display-name" id="pt_${name}_display_name" value="${displayName.replace(/"/g, '&quot;')}"></label>
                    <label>Unit <select class="unit-select" id="pt_${name}_unit">${ptUnitOpts}</select></label>
                    <label><input type="checkbox" id="pt_${name}_enabled" ${cfg.enabled ? 'checked' : ''}> Enabled</label>
                    <label>P min <input type="number" id="pt_${name}_P_min" value="${Number(cfg.P_min)}"></label>
                    <label>P max <input type="number" id="pt_${name}_P_max" value="${Number(cfg.P_max)}"></label>
                    <label>Offset <input type="number" id="pt_${name}_offset" step="0.01" value="${Number(cfg.offset ?? 0)}"></label>
                </div>`;
            }
            html += '</div><div class="modal-section"><h3>RTDs</h3>';
            for (const [name, cfg] of Object.entries(data.rtds)) {
                const displayName = (cfg.display_name != null && cfg.display_name !== undefined) ? String(cfg.display_name) : '';
                const unit = (cfg.unit != null && cfg.unit !== undefined) ? String(cfg.unit) : '°C';
                const rtdUnitOpts = RTD_UNITS.map(u => `<option value="${u.value}" ${u.value === unit ? 'selected' : ''}>${u.label}</option>`).join('');
                html += `<div class="settings-row">
                    <label>${name}</label>
                    <label>Label <input type="text" class="display-name" id="rtd_${name}_display_name" value="${displayName.replace(/"/g, '&quot;')}"></label>
                    <label>Unit <select class="unit-select" id="rtd_${name}_unit">${rtdUnitOpts}</select></label>
                    <label><input type="checkbox" id="rtd_${name}_enabled" ${cfg.enabled ? 'checked' : ''}> Enabled</label>
                    <label>Offset <input type="number" id="rtd_${name}_offset" step="0.01" value="${Number(cfg.offset ?? 0)}"></label>
                </div>`;
            }
            html += '</div>';
            settingsFormContainer.innerHTML = html;
            // Store units from settings so graph value display uses selected unit
            for (const [name, cfg] of Object.entries(data.load_cells || {})) {
                sensorUnits[name] = (cfg.unit != null && cfg.unit !== undefined) ? String(cfg.unit) : 'lbf';
            }
            for (const [name, cfg] of Object.entries(data.pressure_transducers || {})) {
                sensorUnits[name] = (cfg.unit != null && cfg.unit !== undefined) ? String(cfg.unit) : 'Pa';
            }
            for (const [name, cfg] of Object.entries(data.rtds || {})) {
                sensorUnits[name] = (cfg.unit != null && cfg.unit !== undefined) ? String(cfg.unit) : '°C';
            }
            // Update unit when user changes dropdown (no save needed for live display)
            settingsFormContainer.querySelectorAll('select.unit-select').forEach((el) => {
                el.addEventListener('change', () => {
                    const m = el.id.match(/^(lc|pt|rtd)_(.+)_unit$/);
                    if (m) sensorUnits[m[2]] = el.value;
                    // Refresh value display if graph exists
                    if (sensorLabels.length > 0) {
                        sensorLabels.forEach((label) => {
                            const val = sensorCurrentValues[label];
                            const valueDisplay = document.getElementById(`value-${label}`);
                            if (valueDisplay != null && val != null && !isNaN(val)) {
                                const { decimals } = getSensorFormat(label);
                                valueDisplay.textContent = `${val.toFixed(decimals)} ${getDisplayUnit(label)}`;
                            }
                        });
                    }
                });
            });
            // Store display names so graph titles show "ID: name" when set
            sensorDisplayNames = {};
            for (const [name, cfg] of Object.entries(data.load_cells || {})) {
                sensorDisplayNames[name] = (cfg.display_name != null && cfg.display_name !== undefined) ? String(cfg.display_name).trim() : '';
            }
            for (const [name, cfg] of Object.entries(data.pressure_transducers || {})) {
                sensorDisplayNames[name] = (cfg.display_name != null && cfg.display_name !== undefined) ? String(cfg.display_name).trim() : '';
            }
            for (const [name, cfg] of Object.entries(data.rtds || {})) {
                sensorDisplayNames[name] = (cfg.display_name != null && cfg.display_name !== undefined) ? String(cfg.display_name).trim() : '';
            }
            // If graphs already exist, update their titles
            if (sensorLabels.length > 0) {
                sensorLabels.forEach((label) => {
                    const titleEl = document.getElementById(`title-${label}`);
                    if (titleEl && titleEl.firstChild) {
                        titleEl.firstChild.textContent = sensorDisplayNames[label] ? sensorDisplayNames[label] : label;
                    }
                });
            }
            const sdCheck = document.getElementById('adc_settle_discard');
            const sdBtn = document.getElementById('adc_settle_discard_btn');
            const slider = document.getElementById('adc_datarate_code');
            const valueSpan = document.getElementById('adc_datarate_value');
            const rateSummaryEl = document.getElementById('adc_rate_summary');

            function countEnabledSensorsFromDom() {
                let count = 0;
                document.querySelectorAll('input[type="checkbox"]').forEach((el) => {
                    if (!el.id) return;
                    if (/^(lc|pt|rtd)_.+_enabled$/.test(el.id) && el.checked) {
                        count += 1;
                    }
                });
                return count;
            }

            function updateAdcRateSummary() {
                if (!slider || !rateSummaryEl) return;
                const code = Math.min(13, Math.max(0, parseInt(slider.value, 10) || 0));
                const nominalHz = ADC_DATARATE_SPS[code];
                const enabledCount = countEnabledSensorsFromDom();
                const settleOn = sdCheck ? sdCheck.checked : sdInitial;
                if (!nominalHz || enabledCount <= 0) {
                    rateSummaryEl.textContent = `Approx. ADC rate: ${nominalHz || 'n/a'} Hz`;
                    return;
                }
                // Effective per-channel rate: nominal Hz divided by number of enabled sensors;
                // if settle_discard is enabled we effectively throw away every other conversion.
                const discardFactor = settleOn ? 2 : 1;
                const perChannel = nominalHz / discardFactor / enabledCount;
                const perChannelStr = perChannel >= 1 ? perChannel.toFixed(1) : perChannel.toFixed(2);
                const nominalStr = nominalHz >= 1 ? nominalHz.toFixed(1) : nominalHz.toFixed(2);
                const modeText = settleOn ? ' (settle discard ON)' : '';
                rateSummaryEl.textContent =
                    `Approx. ADC rate: ${nominalStr} Hz, ≈ ${perChannelStr} Hz per enabled sensor (${enabledCount} total)` + modeText;
            }

            if (slider && valueSpan) {
                valueSpan.textContent = dr;
                updateAdcRateSummary();
                slider.addEventListener('input', () => {
                    valueSpan.textContent = slider.value;
                    updateAdcRateSummary();
                });
            } else if (rateSummaryEl) {
                updateAdcRateSummary();
            }

            if (sdCheck && sdBtn) {
                sdBtn.addEventListener('click', () => {
                    sdCheck.checked = !sdCheck.checked;
                    sdBtn.classList.toggle('enabled', sdCheck.checked);
                    sdBtn.classList.toggle('disabled', !sdCheck.checked);
                    updateAdcRateSummary();
                });
            }

            // Recompute rate when any Enabled checkbox is toggled
            settingsFormContainer.querySelectorAll('input[type="checkbox"]').forEach((el) => {
                if (!el.id) return;
                if (/^(lc|pt|rtd)_.+_enabled$/.test(el.id)) {
                    el.addEventListener('change', updateAdcRateSummary);
                }
            });
        }

        // Collect form values into payload for POST /api/settings
        function collectSettingsPayload() {
            const load_cells = {};
            const pressure_transducers = {};
            const rtds = {};
            const drEl = document.getElementById('adc_datarate_code');
            const sdEl = document.getElementById('adc_settle_discard');
            const adc = {
                datarate_code: drEl ? Math.min(13, Math.max(0, parseInt(drEl.value, 10) || 0)) : 10,
                settle_discard: sdEl ? sdEl.checked : true
            };
            for (const el of document.querySelectorAll('[id^="lc_"]')) {
                const m = el.id.match(/^lc_(.+)_(enabled|sensitivity|max_load|display_name|unit|offset)$/);
                if (!m) continue;
                const [, name, key] = m;
                if (!load_cells[name]) load_cells[name] = {};
                if (key === 'enabled') load_cells[name].enabled = el.checked;
                else if (key === 'display_name') load_cells[name].display_name = (el.value && typeof el.value === 'string') ? el.value.trim() : '';
                else if (key === 'unit') load_cells[name].unit = (el.value && typeof el.value === 'string') ? el.value.trim() : 'lbf';
                else { const v = parseFloat(el.value); load_cells[name][key] = isNaN(v) ? 0 : v; }
            }
            for (const el of document.querySelectorAll('[id^="pt_"]')) {
                const m = el.id.match(/^pt_(.+)_(enabled|P_min|P_max|display_name|unit|offset)$/);
                if (!m) continue;
                const [, name, key] = m;
                if (!pressure_transducers[name]) pressure_transducers[name] = {};
                if (key === 'enabled') pressure_transducers[name].enabled = el.checked;
                else if (key === 'display_name') pressure_transducers[name].display_name = (el.value && typeof el.value === 'string') ? el.value.trim() : '';
                else if (key === 'unit') pressure_transducers[name].unit = (el.value && typeof el.value === 'string') ? el.value.trim() : 'Pa';
                else { const v = parseFloat(el.value); pressure_transducers[name][key] = isNaN(v) ? 0 : v; }
            }
            for (const el of document.querySelectorAll('[id^="rtd_"]')) {
                const m = el.id.match(/^rtd_(.+)_(enabled|display_name|unit|offset)$/);
                if (!m) continue;
                const [, name, key] = m;
                if (!rtds[name]) rtds[name] = {};
                if (key === 'enabled') rtds[name].enabled = el.checked;
                else if (key === 'display_name') rtds[name].display_name = (el.value && typeof el.value === 'string') ? el.value.trim() : '';
                else if (key === 'unit') rtds[name].unit = (el.value && typeof el.value === 'string') ? el.value.trim() : '°C';
                else { const v = parseFloat(el.value); rtds[name][key] = isNaN(v) ? 0 : v; }
            }
            return { adc, load_cells, pressure_transducers, rtds };
        }

        async function fetchAndPopulateSettings() {
            try {
                const res = await fetch('/api/settings');
                if (res.ok) {
                    const data = await res.json();
                    buildSettingsForm(data);
                    const cfgNameEl = document.getElementById('config-file-name');
                    if (cfgNameEl) {
                        cfgNameEl.textContent = data.config_file_name || 'defaults';
                    }
                }
            } catch (e) {
                console.error('Failed to fetch settings:', e);
            }
        }

        // Config file upload
        const configUploadBtn = document.getElementById('config-upload-btn');
        const configUploadInput = document.getElementById('config-upload-input');
        const configDownloadBtn = document.getElementById('config-download-btn');

        if (configUploadBtn && configUploadInput) {
            configUploadBtn.addEventListener('click', () => configUploadInput.click());
            configUploadInput.addEventListener('change', async () => {
                const file = configUploadInput.files[0];
                if (!file) return;
                try {
                    const text = await file.text();
                    const parsed = JSON.parse(text);
                    const res = await fetch('/api/upload-config', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ settings: parsed, filename: file.name })
                    });
                    const result = await res.json().catch(() => ({}));
                    if (res.ok) {
                        const cfgNameEl = document.getElementById('config-file-name');
                        if (cfgNameEl) cfgNameEl.textContent = result.filename || file.name;
                        settingsSavedMsg.textContent = 'Config uploaded. Restarting...';
                        settingsSavedMsg.classList.add('show');
                        setTimeout(() => {
                            settingsSavedMsg.classList.remove('show');
                            settingsModal.classList.remove('open');
                            settingsModal.setAttribute('aria-hidden', 'true');
                        }, 2000);
                    } else {
                        alert(result.error || 'Failed to upload config');
                    }
                } catch (e) {
                    console.error('Upload config error:', e);
                    alert('Invalid JSON file or upload failed');
                }
                configUploadInput.value = '';
            });
        }

        if (configDownloadBtn) {
            configDownloadBtn.addEventListener('click', async () => {
                try {
                    const res = await fetch('/api/download-config');
                    if (!res.ok) { alert('Failed to download config'); return; }
                    const disposition = res.headers.get('Content-Disposition') || '';
                    const match = disposition.match(/filename=(.+)/);
                    const fname = match ? match[1] : 'DAQ_config.json';
                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fname;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (e) {
                    console.error('Download config error:', e);
                    alert('Failed to download config');
                }
            });
        }

        document.getElementById('settings-button').addEventListener('click', () => {
            fetchAndPopulateSettings();
            settingsModal.classList.add('open');
            settingsModal.setAttribute('aria-hidden', 'false');
        });

        settingsCancelBtn.addEventListener('click', () => {
            settingsModal.classList.remove('open');
            settingsModal.setAttribute('aria-hidden', 'true');
        });

        settingsModal.addEventListener('click', (e) => {
            if (e.target === settingsModal) {
                settingsModal.classList.remove('open');
                settingsModal.setAttribute('aria-hidden', 'true');
            }
        });

        settingsSaveBtn.addEventListener('click', async () => {
            const payload = collectSettingsPayload();
            try {
                const res = await fetch('/api/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await res.json().catch(() => ({}));
                if (res.ok) {
                    settingsSavedMsg.textContent = 'Saved. Restarting...';
                    settingsSavedMsg.classList.add('show');
                    setTimeout(() => {
                        settingsSavedMsg.classList.remove('show');
                        settingsSavedMsg.textContent = 'Saved. Restarting...';
                        settingsModal.classList.remove('open');
                        settingsModal.setAttribute('aria-hidden', 'true');
                    }, 2000);
                } else {
                    alert(data.error || 'Failed to save settings');
                }
            } catch (e) {
                console.error('Save settings error:', e);
                alert('Failed to save settings');
            }
        });

        if (settingsRebootBtn) {
            settingsRebootBtn.addEventListener('click', async () => {
                const sure = window.confirm('Are you sure you want to reboot the Raspberry Pi? This will interrupt data acquisition.');
                if (!sure) return;
                const confirmation = window.prompt('Type "reboot" to restart the Raspberry Pi');
                if (confirmation === null || confirmation === '') {
                    alert('Reboot cancelled.');
                    return;
                }
                try {
                    const res = await fetch('/api/reboot', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ password: confirmation })
                    });
                    const data = await res.json().catch(() => ({}));
                    if (res.ok) {
                        alert('Reboot command sent. The Raspberry Pi will restart shortly.');
                    } else {
                        alert(data.error || 'Failed to initiate reboot');
                    }
                } catch (e) {
                    console.error('Reboot error:', e);
                    alert('Failed to initiate reboot');
                }
            });
        }

        if (settingsShutdownBtn) {
            settingsShutdownBtn.addEventListener('click', async () => {
                const sure = window.confirm('Are you sure you want to shut down the Raspberry Pi? This will interrupt data acquisition.');
                if (!sure) return;
                const confirmation = window.prompt('Type "shutdown" to shut down the Raspberry Pi');
                if (confirmation === null || confirmation === '') {
                    alert('Shutdown cancelled.');
                    return;
                }
                try {
                    const res = await fetch('/api/shutdown', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ password: confirmation })
                    });
                    const data = await res.json().catch(() => ({}));
                    if (res.ok) {
                        alert('Shutdown command sent. The Raspberry Pi will power off shortly.');
                    } else {
                        alert(data.error || 'Failed to initiate shutdown');
                    }
                } catch (e) {
                    console.error('Shutdown error:', e);
                    alert('Failed to initiate shutdown');
                }
            });
        }

        // Load settings on page load so form is ready when user opens modal
        fetchAndPopulateSettings();

        // Connection status handlers
        socket.on('connect', () => {
            console.log('Connected to server');
            connectionIndicator.classList.remove('disconnected');
            connectionIndicator.classList.add('connected');
            if (connectionText) {
                connectionText.textContent = 'online';
            }
        });
        
        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            connectionIndicator.classList.remove('connected');
            connectionIndicator.classList.add('disconnected');
            if (connectionText) {
                connectionText.textContent = 'offline';
            }
        });
        
        socket.on('connected', (data) => {
            console.log('Server confirmed connection:', data);
        });
        
        // System info DOM elements
        const systemInfoContainer = document.getElementById('system-info');
        const systemInfoCompact = document.getElementById('system-info-compact');
        
        // System info handler
        socket.on('system_info', (data) => {
            if (!data) return;
            
            // Show system info container
            if (systemInfoContainer) {
                systemInfoContainer.style.display = 'block';
            }
            
            // Update compact view
            const cpuTempEl = document.getElementById('sys-cpu-temp');
            const ramUsedEl = document.getElementById('sys-ram-used');
            const ramTotalEl = document.getElementById('sys-ram-total');
            const cpuUseEl = document.getElementById('sys-cpu-use');
            const diskPercentEl = document.getElementById('sys-disk-percent');
            
            if (cpuTempEl && data.cpu_temp) {
                cpuTempEl.textContent = data.cpu_temp;
            }
            if (ramUsedEl && data.ram && data.ram.used) {
                ramUsedEl.textContent = data.ram.used;
            }
            if (ramTotalEl && data.ram && data.ram.total) {
                ramTotalEl.textContent = data.ram.total;
            }
            if (cpuUseEl && data.cpu_use) {
                cpuUseEl.textContent = data.cpu_use;
            }
            if (diskPercentEl && data.disk && data.disk.percent) {
                diskPercentEl.textContent = data.disk.percent;
            }
            
            // Update expanded view
            const detailCpuTemp = document.getElementById('sys-detail-cpu-temp');
            const detailRamTotal = document.getElementById('sys-detail-ram-total');
            const detailRamUsed = document.getElementById('sys-detail-ram-used');
            const detailRamFree = document.getElementById('sys-detail-ram-free');
            const detailCpuUse = document.getElementById('sys-detail-cpu-use');
            const detailDiskTotal = document.getElementById('sys-detail-disk-total');
            const detailDiskUsed = document.getElementById('sys-detail-disk-used');
            const detailDiskFree = document.getElementById('sys-detail-disk-free');
            const detailDiskPercent = document.getElementById('sys-detail-disk-percent');
            
            if (detailCpuTemp && data.cpu_temp) {
                detailCpuTemp.textContent = data.cpu_temp + '°C';
            }
            if (detailRamTotal && data.ram && data.ram.total) {
                detailRamTotal.textContent = data.ram.total;
            }
            if (detailRamUsed && data.ram && data.ram.used) {
                detailRamUsed.textContent = data.ram.used;
            }
            if (detailRamFree && data.ram && data.ram.free) {
                detailRamFree.textContent = data.ram.free;
            }
            if (detailCpuUse && data.cpu_use) {
                detailCpuUse.textContent = data.cpu_use + '%';
            }
            if (detailDiskTotal && data.disk && data.disk.total) {
                detailDiskTotal.textContent = data.disk.total;
            }
            if (detailDiskUsed && data.disk && data.disk.used) {
                detailDiskUsed.textContent = data.disk.used;
            }
            if (detailDiskFree && data.disk && data.disk.free) {
                detailDiskFree.textContent = data.disk.free;
            }
            if (detailDiskPercent && data.disk && data.disk.percent) {
                detailDiskPercent.textContent = data.disk.percent;
            }
        });
        
        // Expand/collapse system info on click
        if (systemInfoContainer) {
            systemInfoContainer.addEventListener('click', () => {
                systemInfoContainer.classList.toggle('expanded');
            });
        }
        
        // Sensor data handler
        socket.on('sensor_data', (data) => {
            if (!data.labels || !data.values || !Array.isArray(data.labels) || !Array.isArray(data.values)) {
                console.warn('Invalid sensor data received:', data);
                return;
            }
            
            // Debug: log first few data packets
            if (!sensorLabels.length || Math.random() < 0.01) {
                console.log('Received sensor_data:', { 
                    labels: data.labels, 
                    values: data.values, 
                    time: data.time,
                    numLabels: data.labels.length,
                    numValues: data.values.length 
                });
            }
            
            // Initialize on first data
            if (sensorLabels.length === 0) {
                sensorLabels = data.labels;
                console.log('Initializing graphs for sensors:', sensorLabels);
                initializeGraphs();
                // Resize canvases and start streaming after graphs are created
                setTimeout(() => {
                    resizeCanvases();
                    // Start streaming after canvas is sized
                    sensorLabels.forEach((label) => {
                        const canvas = document.getElementById(`canvas-${label}`);
                        const chart = sensorCharts[label];
                        if (canvas && chart) {
                            // Ensure canvas has valid dimensions
                            if (canvas.width > 0 && canvas.height > 0) {
                                chart.streamTo(canvas, 100);
                                console.log('Started streaming for:', label, 'canvas size:', canvas.width, 'x', canvas.height);
                            } else {
                                console.warn('Canvas not properly sized for:', label, 'retrying...');
                                // Retry after a short delay
                                setTimeout(() => {
                                    resizeCanvases();
                                    if (canvas.width > 0 && canvas.height > 0) {
                                        chart.streamTo(canvas, 100);
                                        console.log('Started streaming for:', label, 'after retry');
                                    }
                                }, 100);
                            }
                        }
                    });
                }, 200);
            }
            
            // Update each sensor's time series (only if graphs are initialized)
            if (sensorLabels.length > 0 && Object.keys(sensorTimeSeries).length > 0) {
                data.labels.forEach((label, index) => {
                    if (sensorTimeSeries[label] && data.values[index] !== undefined && !isNaN(data.values[index])) {
                        const value = parseFloat(data.values[index]);
                        
                        // Use current timestamp for Smoothie.js (it handles the time window automatically)
                        const timestamp = Date.now();
                        
                        // Update time series
                        try {
                            sensorTimeSeries[label].append(timestamp, value);
                            
                            // Update current value display
                            sensorCurrentValues[label] = value;
                            const valueDisplay = document.getElementById(`value-${label}`);
                            if (valueDisplay) {
                                const { decimals } = getSensorFormat(label);
                                valueDisplay.textContent = `${value.toFixed(decimals)} ${getDisplayUnit(label)}`;
                                // Set color to match graph line
                                if (sensorColors[label]) {
                                    valueDisplay.style.color = sensorColors[label];
                                }
                            }
                            
                            // Debug logging (first sensor, occasional)
                            if (index === 0 && Math.random() < 0.05) {
                                console.log('Appended data:', { label, value, timestamp, chartExists: !!sensorCharts[label] });
                            }
                        } catch (error) {
                            console.error('Error appending to TimeSeries:', error, { label, value, timestamp });
                        }
                    
                        // Track min/max for auto-scaling
                        if (!sensorMinMax[label]) {
                            sensorMinMax[label] = { min: value, max: value };
                            // Set initial range
                            const chart = sensorCharts[label];
                            if (chart && chart.options) {
                                const padding = Math.abs(value) * 0.1 || 1;
                                chart.options.minValue = value - padding;
                                chart.options.maxValue = value + padding;
                            }
                        } else {
                            const oldMin = sensorMinMax[label].min;
                            const oldMax = sensorMinMax[label].max;
                            sensorMinMax[label].min = Math.min(sensorMinMax[label].min, value);
                            sensorMinMax[label].max = Math.max(sensorMinMax[label].max, value);
                            
                            // Only update if value is outside current range or range changed significantly
                            const padding = (sensorMinMax[label].max - sensorMinMax[label].min) * 0.1 || 1;
                            const newMin = sensorMinMax[label].min - padding;
                            const newMax = sensorMinMax[label].max + padding;
                            
                            const chart = sensorCharts[label];
                            if (chart && chart.options) {
                                const currentMin = chart.options.minValue || 0;
                                const currentMax = chart.options.maxValue || 100;
                                
                                // Update if value is outside current range or range changed by more than 5%
                                const rangeChange = Math.abs((newMax - newMin) - (currentMax - currentMin));
                                const rangePercent = rangeChange / Math.max(Math.abs(currentMax - currentMin), 1) * 100;
                                
                                if (value < currentMin || value > currentMax || rangePercent > 5) {
                                    chart.options.minValue = newMin;
                                    chart.options.maxValue = newMax;
                                }
                            }
                        }
                    }
                });
            }
        });
        
        // Initialize graphs based on sensor labels
        function initializeGraphs() {
            const numSensors = sensorLabels.length;
            if (numSensors === 0) return;
            
            // Determine grid layout
            let cols, rows;
            if (numSensors === 1) {
                cols = 1;
                rows = 1;
            } else if (numSensors <= 4) {
                cols = 2;
                rows = Math.ceil(numSensors / 2);
            } else {
                cols = 3;
                rows = Math.ceil(numSensors / 3);
            }
            
            graphsContainer.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            graphsContainer.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
            
            // Create graph for each sensor
            sensorLabels.forEach((label, index) => {
                // Create container
                const container = document.createElement('div');
                container.className = 'graph-container rounded p-2';
                container.style.backgroundColor = '#000000';
                container.id = `graph-${label}`;
                container.style.display = 'flex';
                container.style.flexDirection = 'column';
                container.style.height = '100%';
                
                // Create title with value display
                const title = document.createElement('div');
                title.className = 'text-white text-sm font-semibold mb-1 flex justify-between items-center';
                title.id = `title-${label}`;
                const titleText = document.createElement('span');
                titleText.textContent = sensorDisplayNames[label] ? sensorDisplayNames[label] : label;
                const valueDisplay = document.createElement('span');
                valueDisplay.id = `value-${label}`;
                valueDisplay.className = 'font-normal';
                valueDisplay.textContent = '--';
                title.appendChild(titleText);
                title.appendChild(valueDisplay);
                container.appendChild(title);
                
                // Create canvas
                const canvas = document.createElement('canvas');
                canvas.id = `canvas-${label}`;
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                container.appendChild(canvas);
                
                graphsContainer.appendChild(container);
                
                // Create TimeSeries first
                const timeSeries = new TimeSeries();
                
                // Create SmoothieChart - we'll update minValue/maxValue dynamically
                const smoothieChart = new SmoothieChart({
                    grid: {
                        strokeStyle: 'rgba(255, 255, 255, 0.1)',
                        lineWidth: 1,
                        millisPerLine: 1000,
                        verticalSections: 4
                    },
                    labels: {
                        fillStyle: 'rgba(255, 255, 255, 0.8)',
                        fontSize: 10
                    },
                    tooltip: true,
                    responsive: true,
                    millisPerPixel: 10,
                    timestampFormatter: SmoothieChart.timeFormatter,
                    minValue: 0,
                    maxValue: 100
                });
                
                // Assign color from COLOR_LIST (cycle through if more sensors than colors)
                const colorIndex = index % COLOR_LIST.length;
                const lineColor = COLOR_LIST[colorIndex];
                
                smoothieChart.addTimeSeries(timeSeries, {
                    strokeStyle: lineColor,
                    lineWidth: 2
                });
                
                // Store references BEFORE streaming
                sensorCharts[label] = smoothieChart;
                sensorTimeSeries[label] = timeSeries;
                sensorMinMax[label] = null;
                sensorCurrentValues[label] = null;
                sensorColors[label] = lineColor; // Store color for value display
                
                // Set initial color for value display
                if (valueDisplay) {
                    valueDisplay.style.color = lineColor;
                }
            });
        }
        
        // Handle window resize
        let resizeTimeout;
        function resizeCanvases() {
            sensorLabels.forEach((label) => {
                const canvas = document.getElementById(`canvas-${label}`);
                const container = document.getElementById(`graph-${label}`);
                if (canvas && container) {
                    // Get container dimensions
                    const rect = container.getBoundingClientRect();
                    const title = container.querySelector('div');
                    const titleHeight = title ? title.offsetHeight + 8 : 0; // title height + margin
                    const labelSpace = 25; // Space needed for bottom labels
                    // Set canvas size to match container (accounting for padding, title, and labels)
                    const padding = 16; // 8px on each side
                    const width = Math.max(1, rect.width - padding);
                    const height = Math.max(1, rect.height - titleHeight - padding - labelSpace);
                    // Set actual canvas dimensions (not just CSS)
                    canvas.width = width;
                    canvas.height = height;
                }
            });
        }
        
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(resizeCanvases, 100);
        });
        
        // Download CSV: open dropdown and populate from API
        const downloadDropdown = document.getElementById('download-dropdown');
        const downloadDropdownList = document.getElementById('download-dropdown-list');
        const downloadDropdownEmpty = document.getElementById('download-dropdown-empty');

        async function downloadCsvFile(filename) {
            try {
                const response = await fetch(`/data/${filename}`);
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                    if (downloadDropdown) downloadDropdown.classList.remove('open');
                } else {
                    alert('Failed to download file');
                }
            } catch (error) {
                console.error('Download error:', error);
                alert('Error downloading file');
            }
        }

        async function refreshDownloadDropdown() {
            if (!downloadDropdownList || !downloadDropdownEmpty) return;
            try {
                const response = await fetch('/api/data-files');
                if (!response.ok) return;
                const data = await response.json();
                const files = data.files || [];
                const current = data.current || null;
                downloadDropdownList.innerHTML = '';
                if (files.length === 0) {
                    downloadDropdownEmpty.style.display = 'block';
                } else {
                    downloadDropdownEmpty.style.display = 'none';
                    files.forEach((filename) => {
                        const item = document.createElement('div');
                        item.className = 'download-dropdown-item';
                        const nameSpan = document.createElement('span');
                        nameSpan.className = 'filename';
                        nameSpan.textContent = filename;
                        const right = document.createElement('span');
                        right.style.display = 'flex';
                        right.style.alignItems = 'center';
                        right.style.gap = '8px';
                        if (filename === current) {
                            const badge = document.createElement('span');
                            badge.className = 'current-badge';
                            badge.textContent = 'current';
                            right.appendChild(badge);
                        }
                        const dlBtn = document.createElement('button');
                        dlBtn.type = 'button';
                        dlBtn.textContent = 'Download';
                        dlBtn.addEventListener('click', () => downloadCsvFile(filename));
                        right.appendChild(dlBtn);
                        item.appendChild(nameSpan);
                        item.appendChild(right);
                        downloadDropdownList.appendChild(item);
                    });
                }
            } catch (e) {
                console.error('Error fetching data files:', e);
                downloadDropdownEmpty.textContent = 'Failed to load list.';
                downloadDropdownEmpty.style.display = 'block';
            }
        }

        downloadButton.addEventListener('click', (e) => {
            e.stopPropagation();
            if (!downloadDropdown) return;
            const isOpen = downloadDropdown.classList.toggle('open');
            downloadDropdown.setAttribute('aria-hidden', !isOpen);
            if (isOpen) refreshDownloadDropdown();
        });

        document.addEventListener('click', (e) => {
            if (!downloadDropdown || !downloadDropdown.classList.contains('open')) return;
            const wrap = document.querySelector('.download-dropdown-wrap');
            if (wrap && !wrap.contains(e.target)) {
                downloadDropdown.classList.remove('open');
                downloadDropdown.setAttribute('aria-hidden', 'true');
            }
        });
    </script>
</body>
</html>
